// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: metabundle.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>

#if CAPNP_VERSION != 7000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(85984643af66161a);
CAPNP_DECLARE_SCHEMA(dec506fd690dd8a5);
CAPNP_DECLARE_SCHEMA(9af72de6d078e705);
CAPNP_DECLARE_SCHEMA(ee301882f828d643);
CAPNP_DECLARE_SCHEMA(9901242766d94490);
CAPNP_DECLARE_SCHEMA(965d7912ca705835);
CAPNP_DECLARE_SCHEMA(9dd9c59d2671a01f);
CAPNP_DECLARE_SCHEMA(ff98a30c2c755b60);
CAPNP_DECLARE_SCHEMA(dc1adfafd4d96c9d);

}  // namespace schemas
}  // namespace capnp

namespace tmi {
namespace bundleshop {

struct Time {
  Time() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNDEFINED,
    TIMESTAMP,
    FORMATTED,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(85984643af66161a, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UUID {
  UUID() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNDEFINED,
    UNBOUNDED,
    BYTEARRAY,
    LONGWORDS,
  };
  struct Longwords;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dec506fd690dd8a5, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct UUID::Longwords {
  Longwords() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9af72de6d078e705, 3, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

template <typename K = ::capnp::AnyPointer, typename T = ::capnp::AnyPointer>
struct MapT {
  MapT() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct Pair;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee301882f828d643, 0, 1)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, K, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename K, typename T>
struct MapT<K, T>::Pair {
  Pair() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  struct NextHint;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9901242766d94490, 1, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema::Dependency brandDependencies[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, K, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

template <typename K, typename T>
struct MapT<K, T>::Pair::NextHint {
  NextHint() = delete;

  class Reader;
  class Builder;
  class Pipeline;
  enum Which: uint16_t {
    UNDEFINED,
    REFERENCE,
  };

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(965d7912ca705835, 1, 3)
    #if !CAPNP_LITE
    static const ::capnp::_::RawBrandedSchema::Scope brandScopes[];
    static const ::capnp::_::RawBrandedSchema::Binding brandBindings[];
    static const ::capnp::_::RawBrandedSchema specificBrand;
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return ::capnp::_::ChooseBrand<_capnpPrivate, K, T>::brand(); }
    #endif  // !CAPNP_LITE
  };
};

struct Source {
  Source() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9dd9c59d2671a01f, 1, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Bundle {
  Bundle() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff98a30c2c755b60, 2, 16)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Grammar {
  Grammar() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dc1adfafd4d96c9d, 0, 5)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Time::Reader {
public:
  typedef Time Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUndefined() const;
  inline  ::capnp::Void getUndefined() const;

  inline bool isTimestamp() const;
  inline  ::uint64_t getTimestamp() const;

  inline bool isFormatted() const;
  inline bool hasFormatted() const;
  inline  ::capnp::Text::Reader getFormatted() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Time::Builder {
public:
  typedef Time Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUndefined();
  inline  ::capnp::Void getUndefined();
  inline void setUndefined( ::capnp::Void value = ::capnp::VOID);

  inline bool isTimestamp();
  inline  ::uint64_t getTimestamp();
  inline void setTimestamp( ::uint64_t value);

  inline bool isFormatted();
  inline bool hasFormatted();
  inline  ::capnp::Text::Builder getFormatted();
  inline void setFormatted( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFormatted(unsigned int size);
  inline void adoptFormatted(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFormatted();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Time::Pipeline {
public:
  typedef Time Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UUID::Reader {
public:
  typedef UUID Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline Which which() const;
  inline bool isUndefined() const;
  inline  ::capnp::Void getUndefined() const;

  inline bool isUnbounded() const;
  inline bool hasUnbounded() const;
  inline  ::capnp::Data::Reader getUnbounded() const;

  inline bool isBytearray() const;
  inline bool hasBytearray() const;
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader getBytearray() const;

  inline bool isLongwords() const;
  inline typename Longwords::Reader getLongwords() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UUID::Builder {
public:
  typedef UUID Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline Which which();
  inline bool isUndefined();
  inline  ::capnp::Void getUndefined();
  inline void setUndefined( ::capnp::Void value = ::capnp::VOID);

  inline bool isUnbounded();
  inline bool hasUnbounded();
  inline  ::capnp::Data::Builder getUnbounded();
  inline void setUnbounded( ::capnp::Data::Reader value);
  inline  ::capnp::Data::Builder initUnbounded(unsigned int size);
  inline void adoptUnbounded(::capnp::Orphan< ::capnp::Data>&& value);
  inline ::capnp::Orphan< ::capnp::Data> disownUnbounded();

  inline bool isBytearray();
  inline bool hasBytearray();
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder getBytearray();
  inline void setBytearray( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value);
  inline void setBytearray(::kj::ArrayPtr<const  ::uint8_t> value);
  inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder initBytearray(unsigned int size);
  inline void adoptBytearray(::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> disownBytearray();

  inline bool isLongwords();
  inline typename Longwords::Builder getLongwords();
  inline typename Longwords::Builder initLongwords();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UUID::Pipeline {
public:
  typedef UUID Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class UUID::Longwords::Reader {
public:
  typedef Longwords Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getHi() const;

  inline  ::uint64_t getLo() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class UUID::Longwords::Builder {
public:
  typedef Longwords Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint64_t getHi();
  inline void setHi( ::uint64_t value);

  inline  ::uint64_t getLo();
  inline void setLo( ::uint64_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class UUID::Longwords::Pipeline {
public:
  typedef Longwords Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename K, typename T>
class MapT<K, T>::Reader {
public:
  typedef MapT Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Reader asGeneric() {
    return typename MapT<K2, T2>::Reader(_reader);
  }

  inline bool hasEntries() const;
  inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Reader getEntries() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename K, typename T>
class MapT<K, T>::Builder {
public:
  typedef MapT Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Builder asGeneric() {
    return typename MapT<K2, T2>::Builder(_builder);
  }

  inline bool hasEntries();
  inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Builder getEntries();
  inline void setEntries(typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Reader value);
  inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Builder initEntries(unsigned int size);
  inline void adoptEntries(::capnp::Orphan< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>> disownEntries();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename K, typename T>
class MapT<K, T>::Pipeline {
public:
  typedef MapT Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename K, typename T>
class MapT<K, T>::Pair::Reader {
public:
  typedef Pair Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Pair::Reader asMapTGeneric() {
    return typename MapT<K2, T2>::Pair::Reader(_reader);
  }

  inline bool hasKey() const;
  inline  ::capnp::ReaderFor<K> getKey() const;

  inline bool hasValue() const;
  inline  ::capnp::ReaderFor<T> getValue() const;

  inline typename NextHint::Reader getNextHint() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename K, typename T>
class MapT<K, T>::Pair::Builder {
public:
  typedef Pair Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Pair::Builder asMapTGeneric() {
    return typename MapT<K2, T2>::Pair::Builder(_builder);
  }

  inline bool hasKey();
  inline  ::capnp::BuilderFor<K> getKey();
  inline void setKey( ::capnp::ReaderFor<K> value);
  inline  ::capnp::BuilderFor<K> initKey();
  inline  ::capnp::BuilderFor<K> initKey(unsigned int size);
  inline void adoptKey(::capnp::Orphan<K>&& value);
  inline ::capnp::Orphan<K> disownKey();

  inline bool hasValue();
  inline  ::capnp::BuilderFor<T> getValue();
  inline void setValue( ::capnp::ReaderFor<T> value);
  inline  ::capnp::BuilderFor<T> initValue();
  inline  ::capnp::BuilderFor<T> initValue(unsigned int size);
  inline void adoptValue(::capnp::Orphan<T>&& value);
  inline ::capnp::Orphan<T> disownValue();

  inline typename NextHint::Builder getNextHint();
  inline typename NextHint::Builder initNextHint();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename K, typename T>
class MapT<K, T>::Pair::Pipeline {
public:
  typedef Pair Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::capnp::PipelineFor<K> getKey();
  inline  ::capnp::PipelineFor<T> getValue();
  inline typename NextHint::Pipeline getNextHint();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

template <typename K, typename T>
class MapT<K, T>::Pair::NextHint::Reader {
public:
  typedef NextHint Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Pair::Reader asMapTGeneric() {
    return typename MapT<K2, T2>::Pair::Reader(_reader);
  }

  inline Which which() const;
  inline bool isUndefined() const;
  inline  ::capnp::Void getUndefined() const;

  inline bool isReference() const;
  inline bool hasReference() const;
  inline ::capnp::AnyPointer::Reader getReference() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

template <typename K, typename T>
class MapT<K, T>::Pair::NextHint::Builder {
public:
  typedef NextHint Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  template <typename K2 = ::capnp::AnyPointer, typename T2 = ::capnp::AnyPointer>
  typename MapT<K2, T2>::Pair::Builder asMapTGeneric() {
    return typename MapT<K2, T2>::Pair::Builder(_builder);
  }

  inline Which which();
  inline bool isUndefined();
  inline  ::capnp::Void getUndefined();
  inline void setUndefined( ::capnp::Void value = ::capnp::VOID);

  inline bool isReference();
  inline bool hasReference();
  inline ::capnp::AnyPointer::Builder getReference();
  inline ::capnp::AnyPointer::Builder initReference();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
template <typename K, typename T>
class MapT<K, T>::Pair::NextHint::Pipeline {
public:
  typedef NextHint Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Source::Reader {
public:
  typedef Source Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasIdentifier() const;
  inline  ::capnp::Text::Reader getIdentifier() const;

  inline bool hasUrl() const;
  inline  ::capnp::Text::Reader getUrl() const;

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline  ::int32_t getRank() const;

  inline bool getDisabled() const;

  inline bool hasKeychain() const;
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader getKeychain() const;

  inline bool hasPathUpdated() const;
  inline  ::tmi::bundleshop::Time::Reader getPathUpdated() const;

  inline bool getUpdateAvailable() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Source::Builder {
public:
  typedef Source Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasIdentifier();
  inline  ::capnp::Text::Builder getIdentifier();
  inline void setIdentifier( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initIdentifier(unsigned int size);
  inline void adoptIdentifier(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownIdentifier();

  inline bool hasUrl();
  inline  ::capnp::Text::Builder getUrl();
  inline void setUrl( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initUrl(unsigned int size);
  inline void adoptUrl(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownUrl();

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline  ::int32_t getRank();
  inline void setRank( ::int32_t value);

  inline bool getDisabled();
  inline void setDisabled(bool value);

  inline bool hasKeychain();
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder getKeychain();
  inline void setKeychain( ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader value);
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder initKeychain();
  inline void adoptKeychain(::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>> disownKeychain();

  inline bool hasPathUpdated();
  inline  ::tmi::bundleshop::Time::Builder getPathUpdated();
  inline void setPathUpdated( ::tmi::bundleshop::Time::Reader value);
  inline  ::tmi::bundleshop::Time::Builder initPathUpdated();
  inline void adoptPathUpdated(::capnp::Orphan< ::tmi::bundleshop::Time>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::Time> disownPathUpdated();

  inline bool getUpdateAvailable();
  inline void setUpdateAvailable(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Source::Pipeline {
public:
  typedef Source Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline getKeychain();
  inline  ::tmi::bundleshop::Time::Pipeline getPathUpdated();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Bundle::Reader {
public:
  typedef Bundle Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUuid() const;
  inline  ::tmi::bundleshop::UUID::Reader getUuid() const;

  inline bool hasOrigin() const;
  inline  ::capnp::Text::Reader getOrigin() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasCategory() const;
  inline  ::capnp::Text::Reader getCategory() const;

  inline bool hasHtmlURL() const;
  inline  ::capnp::Text::Reader getHtmlURL() const;

  inline bool hasDescription() const;
  inline  ::capnp::Text::Reader getDescription() const;

  inline bool hasContactName() const;
  inline  ::capnp::Text::Reader getContactName() const;

  inline bool hasContactEmail() const;
  inline  ::capnp::Text::Reader getContactEmail() const;

  inline bool hasUrl() const;
  inline  ::capnp::Text::Reader getUrl() const;

  inline bool hasUrlUpdated() const;
  inline  ::tmi::bundleshop::Time::Reader getUrlUpdated() const;

  inline bool hasPath() const;
  inline  ::capnp::Text::Reader getPath() const;

  inline bool hasPathUpdated() const;
  inline  ::tmi::bundleshop::Time::Reader getPathUpdated() const;

  inline  ::int32_t getRank() const;

  inline  ::int32_t getSize() const;

  inline bool getRequisite() const;

  inline bool getDefault() const;

  inline bool getDependency() const;

  inline bool getInstalled() const;

  inline bool getUpdateAvailable() const;

  inline bool hasKeychain() const;
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader getKeychain() const;

  inline bool hasGrammars() const;
  inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Reader getGrammars() const;

  inline bool hasDependants() const;
  inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Reader getDependants() const;

  inline bool hasSource() const;
  inline  ::tmi::bundleshop::Source::Reader getSource() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Bundle::Builder {
public:
  typedef Bundle Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUuid();
  inline  ::tmi::bundleshop::UUID::Builder getUuid();
  inline void setUuid( ::tmi::bundleshop::UUID::Reader value);
  inline  ::tmi::bundleshop::UUID::Builder initUuid();
  inline void adoptUuid(::capnp::Orphan< ::tmi::bundleshop::UUID>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::UUID> disownUuid();

  inline bool hasOrigin();
  inline  ::capnp::Text::Builder getOrigin();
  inline void setOrigin( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initOrigin(unsigned int size);
  inline void adoptOrigin(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownOrigin();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasCategory();
  inline  ::capnp::Text::Builder getCategory();
  inline void setCategory( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initCategory(unsigned int size);
  inline void adoptCategory(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownCategory();

  inline bool hasHtmlURL();
  inline  ::capnp::Text::Builder getHtmlURL();
  inline void setHtmlURL( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initHtmlURL(unsigned int size);
  inline void adoptHtmlURL(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownHtmlURL();

  inline bool hasDescription();
  inline  ::capnp::Text::Builder getDescription();
  inline void setDescription( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initDescription(unsigned int size);
  inline void adoptDescription(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownDescription();

  inline bool hasContactName();
  inline  ::capnp::Text::Builder getContactName();
  inline void setContactName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initContactName(unsigned int size);
  inline void adoptContactName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownContactName();

  inline bool hasContactEmail();
  inline  ::capnp::Text::Builder getContactEmail();
  inline void setContactEmail( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initContactEmail(unsigned int size);
  inline void adoptContactEmail(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownContactEmail();

  inline bool hasUrl();
  inline  ::capnp::Text::Builder getUrl();
  inline void setUrl( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initUrl(unsigned int size);
  inline void adoptUrl(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownUrl();

  inline bool hasUrlUpdated();
  inline  ::tmi::bundleshop::Time::Builder getUrlUpdated();
  inline void setUrlUpdated( ::tmi::bundleshop::Time::Reader value);
  inline  ::tmi::bundleshop::Time::Builder initUrlUpdated();
  inline void adoptUrlUpdated(::capnp::Orphan< ::tmi::bundleshop::Time>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::Time> disownUrlUpdated();

  inline bool hasPath();
  inline  ::capnp::Text::Builder getPath();
  inline void setPath( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initPath(unsigned int size);
  inline void adoptPath(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownPath();

  inline bool hasPathUpdated();
  inline  ::tmi::bundleshop::Time::Builder getPathUpdated();
  inline void setPathUpdated( ::tmi::bundleshop::Time::Reader value);
  inline  ::tmi::bundleshop::Time::Builder initPathUpdated();
  inline void adoptPathUpdated(::capnp::Orphan< ::tmi::bundleshop::Time>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::Time> disownPathUpdated();

  inline  ::int32_t getRank();
  inline void setRank( ::int32_t value);

  inline  ::int32_t getSize();
  inline void setSize( ::int32_t value);

  inline bool getRequisite();
  inline void setRequisite(bool value);

  inline bool getDefault();
  inline void setDefault(bool value);

  inline bool getDependency();
  inline void setDependency(bool value);

  inline bool getInstalled();
  inline void setInstalled(bool value);

  inline bool getUpdateAvailable();
  inline void setUpdateAvailable(bool value);

  inline bool hasKeychain();
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder getKeychain();
  inline void setKeychain( ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader value);
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder initKeychain();
  inline void adoptKeychain(::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>> disownKeychain();

  inline bool hasGrammars();
  inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Builder getGrammars();
  inline void setGrammars( ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Builder initGrammars(unsigned int size);
  inline void adoptGrammars(::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>> disownGrammars();

  inline bool hasDependants();
  inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Builder getDependants();
  inline void setDependants( ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Builder initDependants(unsigned int size);
  inline void adoptDependants(::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>> disownDependants();

  inline bool hasSource();
  inline  ::tmi::bundleshop::Source::Builder getSource();
  inline void setSource( ::tmi::bundleshop::Source::Reader value);
  inline  ::tmi::bundleshop::Source::Builder initSource();
  inline void adoptSource(::capnp::Orphan< ::tmi::bundleshop::Source>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::Source> disownSource();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Bundle::Pipeline {
public:
  typedef Bundle Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::tmi::bundleshop::UUID::Pipeline getUuid();
  inline  ::tmi::bundleshop::Time::Pipeline getUrlUpdated();
  inline  ::tmi::bundleshop::Time::Pipeline getPathUpdated();
  inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline getKeychain();
  inline  ::tmi::bundleshop::Source::Pipeline getSource();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Grammar::Reader {
public:
  typedef Grammar Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasUuid() const;
  inline  ::tmi::bundleshop::UUID::Reader getUuid() const;

  inline bool hasScope() const;
  inline  ::capnp::Text::Reader getScope() const;

  inline bool hasName() const;
  inline  ::capnp::Text::Reader getName() const;

  inline bool hasFileTypes() const;
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader getFileTypes() const;

  inline bool hasModeLine() const;
  inline  ::capnp::Text::Reader getModeLine() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Grammar::Builder {
public:
  typedef Grammar Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasUuid();
  inline  ::tmi::bundleshop::UUID::Builder getUuid();
  inline void setUuid( ::tmi::bundleshop::UUID::Reader value);
  inline  ::tmi::bundleshop::UUID::Builder initUuid();
  inline void adoptUuid(::capnp::Orphan< ::tmi::bundleshop::UUID>&& value);
  inline ::capnp::Orphan< ::tmi::bundleshop::UUID> disownUuid();

  inline bool hasScope();
  inline  ::capnp::Text::Builder getScope();
  inline void setScope( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initScope(unsigned int size);
  inline void adoptScope(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownScope();

  inline bool hasName();
  inline  ::capnp::Text::Builder getName();
  inline void setName( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initName(unsigned int size);
  inline void adoptName(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownName();

  inline bool hasFileTypes();
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder getFileTypes();
  inline void setFileTypes( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value);
  inline void setFileTypes(::kj::ArrayPtr<const  ::capnp::Text::Reader> value);
  inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder initFileTypes(unsigned int size);
  inline void adoptFileTypes(::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> disownFileTypes();

  inline bool hasModeLine();
  inline  ::capnp::Text::Builder getModeLine();
  inline void setModeLine( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initModeLine(unsigned int size);
  inline void adoptModeLine(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownModeLine();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Grammar::Pipeline {
public:
  typedef Grammar Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::tmi::bundleshop::UUID::Pipeline getUuid();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline  ::tmi::bundleshop::Time::Which Time::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::tmi::bundleshop::Time::Which Time::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Time::Reader::isUndefined() const {
  return which() == Time::UNDEFINED;
}
inline bool Time::Builder::isUndefined() {
  return which() == Time::UNDEFINED;
}
inline  ::capnp::Void Time::Reader::getUndefined() const {
  KJ_IREQUIRE((which() == Time::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void Time::Builder::getUndefined() {
  KJ_IREQUIRE((which() == Time::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Time::Builder::setUndefined( ::capnp::Void value) {
  _builder.setDataField<Time::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Time::UNDEFINED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Time::Reader::isTimestamp() const {
  return which() == Time::TIMESTAMP;
}
inline bool Time::Builder::isTimestamp() {
  return which() == Time::TIMESTAMP;
}
inline  ::uint64_t Time::Reader::getTimestamp() const {
  KJ_IREQUIRE((which() == Time::TIMESTAMP),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t Time::Builder::getTimestamp() {
  KJ_IREQUIRE((which() == Time::TIMESTAMP),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Time::Builder::setTimestamp( ::uint64_t value) {
  _builder.setDataField<Time::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Time::TIMESTAMP);
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Time::Reader::isFormatted() const {
  return which() == Time::FORMATTED;
}
inline bool Time::Builder::isFormatted() {
  return which() == Time::FORMATTED;
}
inline bool Time::Reader::hasFormatted() const {
  if (which() != Time::FORMATTED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Time::Builder::hasFormatted() {
  if (which() != Time::FORMATTED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Time::Reader::getFormatted() const {
  KJ_IREQUIRE((which() == Time::FORMATTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Time::Builder::getFormatted() {
  KJ_IREQUIRE((which() == Time::FORMATTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Time::Builder::setFormatted( ::capnp::Text::Reader value) {
  _builder.setDataField<Time::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Time::FORMATTED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Time::Builder::initFormatted(unsigned int size) {
  _builder.setDataField<Time::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Time::FORMATTED);
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Time::Builder::adoptFormatted(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  _builder.setDataField<Time::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, Time::FORMATTED);
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Time::Builder::disownFormatted() {
  KJ_IREQUIRE((which() == Time::FORMATTED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline  ::tmi::bundleshop::UUID::Which UUID::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline  ::tmi::bundleshop::UUID::Which UUID::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool UUID::Reader::isUndefined() const {
  return which() == UUID::UNDEFINED;
}
inline bool UUID::Builder::isUndefined() {
  return which() == UUID::UNDEFINED;
}
inline  ::capnp::Void UUID::Reader::getUndefined() const {
  KJ_IREQUIRE((which() == UUID::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::capnp::Void UUID::Builder::getUndefined() {
  KJ_IREQUIRE((which() == UUID::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void UUID::Builder::setUndefined( ::capnp::Void value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::UNDEFINED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool UUID::Reader::isUnbounded() const {
  return which() == UUID::UNBOUNDED;
}
inline bool UUID::Builder::isUnbounded() {
  return which() == UUID::UNBOUNDED;
}
inline bool UUID::Reader::hasUnbounded() const {
  if (which() != UUID::UNBOUNDED) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UUID::Builder::hasUnbounded() {
  if (which() != UUID::UNBOUNDED) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Data::Reader UUID::Reader::getUnbounded() const {
  KJ_IREQUIRE((which() == UUID::UNBOUNDED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Data::Builder UUID::Builder::getUnbounded() {
  KJ_IREQUIRE((which() == UUID::UNBOUNDED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UUID::Builder::setUnbounded( ::capnp::Data::Reader value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::UNBOUNDED);
  ::capnp::_::PointerHelpers< ::capnp::Data>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Data::Builder UUID::Builder::initUnbounded(unsigned int size) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::UNBOUNDED);
  return ::capnp::_::PointerHelpers< ::capnp::Data>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UUID::Builder::adoptUnbounded(
    ::capnp::Orphan< ::capnp::Data>&& value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::UNBOUNDED);
  ::capnp::_::PointerHelpers< ::capnp::Data>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Data> UUID::Builder::disownUnbounded() {
  KJ_IREQUIRE((which() == UUID::UNBOUNDED),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::Data>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UUID::Reader::isBytearray() const {
  return which() == UUID::BYTEARRAY;
}
inline bool UUID::Builder::isBytearray() {
  return which() == UUID::BYTEARRAY;
}
inline bool UUID::Reader::hasBytearray() const {
  if (which() != UUID::BYTEARRAY) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool UUID::Builder::hasBytearray() {
  if (which() != UUID::BYTEARRAY) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader UUID::Reader::getBytearray() const {
  KJ_IREQUIRE((which() == UUID::BYTEARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder UUID::Builder::getBytearray() {
  KJ_IREQUIRE((which() == UUID::BYTEARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void UUID::Builder::setBytearray( ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Reader value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::BYTEARRAY);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline void UUID::Builder::setBytearray(::kj::ArrayPtr<const  ::uint8_t> value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::BYTEARRAY);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>::Builder UUID::Builder::initBytearray(unsigned int size) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::BYTEARRAY);
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void UUID::Builder::adoptBytearray(
    ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>&& value) {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::BYTEARRAY);
  ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>> UUID::Builder::disownBytearray() {
  KJ_IREQUIRE((which() == UUID::BYTEARRAY),
              "Must check which() before get()ing a union member.");
  return ::capnp::_::PointerHelpers< ::capnp::List< ::uint8_t,  ::capnp::Kind::PRIMITIVE>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool UUID::Reader::isLongwords() const {
  return which() == UUID::LONGWORDS;
}
inline bool UUID::Builder::isLongwords() {
  return which() == UUID::LONGWORDS;
}
inline typename UUID::Longwords::Reader UUID::Reader::getLongwords() const {
  KJ_IREQUIRE((which() == UUID::LONGWORDS),
              "Must check which() before get()ing a union member.");
  return typename UUID::Longwords::Reader(_reader);
}
inline typename UUID::Longwords::Builder UUID::Builder::getLongwords() {
  KJ_IREQUIRE((which() == UUID::LONGWORDS),
              "Must check which() before get()ing a union member.");
  return typename UUID::Longwords::Builder(_builder);
}
inline typename UUID::Longwords::Builder UUID::Builder::initLongwords() {
  _builder.setDataField<UUID::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, UUID::LONGWORDS);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<1>() * ::capnp::ELEMENTS, 0);
  _builder.setDataField< ::uint64_t>(::capnp::bounded<2>() * ::capnp::ELEMENTS, 0);
  return typename UUID::Longwords::Builder(_builder);
}
inline  ::uint64_t UUID::Longwords::Reader::getHi() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UUID::Longwords::Builder::getHi() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void UUID::Longwords::Builder::setHi( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint64_t UUID::Longwords::Reader::getLo() const {
  return _reader.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint64_t UUID::Longwords::Builder::getLo() {
  return _builder.getDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void UUID::Longwords::Builder::setLo( ::uint64_t value) {
  _builder.setDataField< ::uint64_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

template <typename K, typename T>
inline bool MapT<K, T>::Reader::hasEntries() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline bool MapT<K, T>::Builder::hasEntries() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Reader MapT<K, T>::Reader::getEntries() const {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Builder MapT<K, T>::Builder::getEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline void MapT<K, T>::Builder::setEntries(typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename K, typename T>
inline typename  ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>::Builder MapT<K, T>::Builder::initEntries(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename K, typename T>
inline void MapT<K, T>::Builder::adoptEntries(
    ::capnp::Orphan< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename K, typename T>
inline ::capnp::Orphan< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>> MapT<K, T>::Builder::disownEntries() {
  return ::capnp::_::PointerHelpers< ::capnp::List<typename  ::tmi::bundleshop::MapT<K, T>::Pair,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename K, typename T>
inline bool MapT<K, T>::Pair::Reader::hasKey() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::Builder::hasKey() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline  ::capnp::ReaderFor<K> MapT<K, T>::Pair::Reader::getKey() const {
  return ::capnp::_::PointerHelpers<K>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<K> MapT<K, T>::Pair::Builder::getKey() {
  return ::capnp::_::PointerHelpers<K>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename K, typename T>
inline  ::capnp::PipelineFor<K> MapT<K, T>::Pair::Pipeline::getKey() {
  return  ::capnp::PipelineFor<K>(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
template <typename K, typename T>
inline void MapT<K, T>::Pair::Builder::setKey( ::capnp::ReaderFor<K> value) {
  ::capnp::_::PointerHelpers<K>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<K> MapT<K, T>::Pair::Builder::initKey() {
  return ::capnp::_::PointerHelpers<K>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<K> MapT<K, T>::Pair::Builder::initKey(unsigned int size) {
  return ::capnp::_::PointerHelpers<K>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
template <typename K, typename T>
inline void MapT<K, T>::Pair::Builder::adoptKey(
    ::capnp::Orphan<K>&& value) {
  ::capnp::_::PointerHelpers<K>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename K, typename T>
inline ::capnp::Orphan<K> MapT<K, T>::Pair::Builder::disownKey() {
  return ::capnp::_::PointerHelpers<K>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

template <typename K, typename T>
inline bool MapT<K, T>::Pair::Reader::hasValue() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::Builder::hasValue() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline  ::capnp::ReaderFor<T> MapT<K, T>::Pair::Reader::getValue() const {
  return ::capnp::_::PointerHelpers<T>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<T> MapT<K, T>::Pair::Builder::getValue() {
  return ::capnp::_::PointerHelpers<T>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
template <typename K, typename T>
inline  ::capnp::PipelineFor<T> MapT<K, T>::Pair::Pipeline::getValue() {
  return  ::capnp::PipelineFor<T>(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
template <typename K, typename T>
inline void MapT<K, T>::Pair::Builder::setValue( ::capnp::ReaderFor<T> value) {
  ::capnp::_::PointerHelpers<T>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<T> MapT<K, T>::Pair::Builder::initValue() {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline  ::capnp::BuilderFor<T> MapT<K, T>::Pair::Builder::initValue(unsigned int size) {
  return ::capnp::_::PointerHelpers<T>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
template <typename K, typename T>
inline void MapT<K, T>::Pair::Builder::adoptValue(
    ::capnp::Orphan<T>&& value) {
  ::capnp::_::PointerHelpers<T>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
template <typename K, typename T>
inline ::capnp::Orphan<T> MapT<K, T>::Pair::Builder::disownValue() {
  return ::capnp::_::PointerHelpers<T>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

template <typename K, typename T>
inline typename MapT<K, T>::Pair::NextHint::Reader MapT<K, T>::Pair::Reader::getNextHint() const {
  return typename MapT<K, T>::Pair::NextHint::Reader(_reader);
}
template <typename K, typename T>
inline typename MapT<K, T>::Pair::NextHint::Builder MapT<K, T>::Pair::Builder::getNextHint() {
  return typename MapT<K, T>::Pair::NextHint::Builder(_builder);
}
#if !CAPNP_LITE
template <typename K, typename T>
inline typename MapT<K, T>::Pair::NextHint::Pipeline MapT<K, T>::Pair::Pipeline::getNextHint() {
  return typename MapT<K, T>::Pair::NextHint::Pipeline(_typeless.noop());
}
#endif  // !CAPNP_LITE
template <typename K, typename T>
inline typename MapT<K, T>::Pair::NextHint::Builder MapT<K, T>::Pair::Builder::initNextHint() {
  _builder.setDataField< ::uint16_t>(::capnp::bounded<0>() * ::capnp::ELEMENTS, 0);
  _builder.getPointerField(::capnp::bounded<2>() * ::capnp::POINTERS).clear();
  return typename MapT<K, T>::Pair::NextHint::Builder(_builder);
}
template <typename K, typename T>
inline typename  ::tmi::bundleshop::MapT<K, T>::Pair::NextHint::Which MapT<K, T>::Pair::NextHint::Reader::which() const {
  return _reader.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename K, typename T>
inline typename  ::tmi::bundleshop::MapT<K, T>::Pair::NextHint::Which MapT<K, T>::Pair::NextHint::Builder::which() {
  return _builder.getDataField<Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Reader::isUndefined() const {
  return which() == MapT<K, T>::Pair::NextHint::UNDEFINED;
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Builder::isUndefined() {
  return which() == MapT<K, T>::Pair::NextHint::UNDEFINED;
}
template <typename K, typename T>
inline  ::capnp::Void MapT<K, T>::Pair::NextHint::Reader::getUndefined() const {
  KJ_IREQUIRE((which() == MapT<K, T>::Pair::NextHint::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _reader.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

template <typename K, typename T>
inline  ::capnp::Void MapT<K, T>::Pair::NextHint::Builder::getUndefined() {
  KJ_IREQUIRE((which() == MapT<K, T>::Pair::NextHint::UNDEFINED),
              "Must check which() before get()ing a union member.");
  return _builder.getDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
template <typename K, typename T>
inline void MapT<K, T>::Pair::NextHint::Builder::setUndefined( ::capnp::Void value) {
  _builder.setDataField<MapT<K, T>::Pair::NextHint::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MapT<K, T>::Pair::NextHint::UNDEFINED);
  _builder.setDataField< ::capnp::Void>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Reader::isReference() const {
  return which() == MapT<K, T>::Pair::NextHint::REFERENCE;
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Builder::isReference() {
  return which() == MapT<K, T>::Pair::NextHint::REFERENCE;
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Reader::hasReference() const {
  if (which() != MapT<K, T>::Pair::NextHint::REFERENCE) return false;
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline bool MapT<K, T>::Pair::NextHint::Builder::hasReference() {
  if (which() != MapT<K, T>::Pair::NextHint::REFERENCE) return false;
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
template <typename K, typename T>
inline ::capnp::AnyPointer::Reader MapT<K, T>::Pair::NextHint::Reader::getReference() const {
  KJ_IREQUIRE((which() == MapT<K, T>::Pair::NextHint::REFERENCE),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Reader(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline ::capnp::AnyPointer::Builder MapT<K, T>::Pair::NextHint::Builder::getReference() {
  KJ_IREQUIRE((which() == MapT<K, T>::Pair::NextHint::REFERENCE),
              "Must check which() before get()ing a union member.");
  return ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
template <typename K, typename T>
inline ::capnp::AnyPointer::Builder MapT<K, T>::Pair::NextHint::Builder::initReference() {
  _builder.setDataField<MapT<K, T>::Pair::NextHint::Which>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, MapT<K, T>::Pair::NextHint::REFERENCE);
  auto result = ::capnp::AnyPointer::Builder(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
  result.clear();
  return result;
}

// MapT<K, T>::Pair::NextHint
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::Pair::NextHint::_capnpPrivate::dataWordSize;
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::Pair::NextHint::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename K, typename T>
constexpr ::capnp::Kind MapT<K, T>::Pair::NextHint::_capnpPrivate::kind;
template <typename K, typename T>
constexpr ::capnp::_::RawSchema const* MapT<K, T>::Pair::NextHint::_capnpPrivate::schema;
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Scope MapT<K, T>::Pair::NextHint::_capnpPrivate::brandScopes[] = {
  { 0xee301882f828d643, brandBindings + 0, 2, false},
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Binding MapT<K, T>::Pair::NextHint::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<K>(),
  ::capnp::_::brandBindingFor<T>(),
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema MapT<K, T>::Pair::NextHint::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_965d7912ca705835, brandScopes, nullptr,
  1, 0, nullptr
};
#endif  // !CAPNP_LITE

// MapT<K, T>::Pair
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::Pair::_capnpPrivate::dataWordSize;
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::Pair::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename K, typename T>
constexpr ::capnp::Kind MapT<K, T>::Pair::_capnpPrivate::kind;
template <typename K, typename T>
constexpr ::capnp::_::RawSchema const* MapT<K, T>::Pair::_capnpPrivate::schema;
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Scope MapT<K, T>::Pair::_capnpPrivate::brandScopes[] = {
  { 0xee301882f828d643, brandBindings + 0, 2, false},
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Binding MapT<K, T>::Pair::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<K>(),
  ::capnp::_::brandBindingFor<T>(),
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Dependency MapT<K, T>::Pair::_capnpPrivate::brandDependencies[] = {
  { 16777218,  ::tmi::bundleshop::MapT<K, T>::Pair::NextHint::_capnpPrivate::brand() },
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema MapT<K, T>::Pair::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_9901242766d94490, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

// MapT<K, T>
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::_capnpPrivate::dataWordSize;
template <typename K, typename T>
constexpr uint16_t MapT<K, T>::_capnpPrivate::pointerCount;
#if !CAPNP_LITE
template <typename K, typename T>
constexpr ::capnp::Kind MapT<K, T>::_capnpPrivate::kind;
template <typename K, typename T>
constexpr ::capnp::_::RawSchema const* MapT<K, T>::_capnpPrivate::schema;
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Scope MapT<K, T>::_capnpPrivate::brandScopes[] = {
  { 0xee301882f828d643, brandBindings + 0, 2, false},
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Binding MapT<K, T>::_capnpPrivate::brandBindings[] = {
  ::capnp::_::brandBindingFor<K>(),
  ::capnp::_::brandBindingFor<T>(),
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema::Dependency MapT<K, T>::_capnpPrivate::brandDependencies[] = {
  { 16777216,  ::tmi::bundleshop::MapT<K, T>::Pair::_capnpPrivate::brand() },
};
template <typename K, typename T>
const ::capnp::_::RawBrandedSchema MapT<K, T>::_capnpPrivate::specificBrand = {
  &::capnp::schemas::s_ee301882f828d643, brandScopes, brandDependencies,
  1, 1, nullptr
};
#endif  // !CAPNP_LITE

inline bool Source::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Source::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Source::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Source::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Source::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Source::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Source::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Source::Reader::hasIdentifier() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasIdentifier() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Source::Reader::getIdentifier() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Source::Builder::getIdentifier() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Source::Builder::setIdentifier( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Source::Builder::initIdentifier(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Source::Builder::adoptIdentifier(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Source::Builder::disownIdentifier() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Source::Reader::hasUrl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasUrl() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Source::Reader::getUrl() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Source::Builder::getUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Source::Builder::setUrl( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Source::Builder::initUrl(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Source::Builder::adoptUrl(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Source::Builder::disownUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Source::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Source::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Source::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Source::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Source::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Source::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Source::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline  ::int32_t Source::Reader::getRank() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Source::Builder::getRank() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Source::Builder::setRank( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Source::Reader::getDisabled() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}

inline bool Source::Builder::getDisabled() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS);
}
inline void Source::Builder::setDisabled(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<32>() * ::capnp::ELEMENTS, value);
}

inline bool Source::Reader::hasKeychain() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasKeychain() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader Source::Reader::getKeychain() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder Source::Builder::getKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline Source::Pipeline::getKeychain() {
  return  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Source::Builder::setKeychain( ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder Source::Builder::initKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Source::Builder::adoptKeychain(
    ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>> Source::Builder::disownKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Source::Reader::hasPathUpdated() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Source::Builder::hasPathUpdated() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::Time::Reader Source::Reader::getPathUpdated() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::Time::Builder Source::Builder::getPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::Time::Pipeline Source::Pipeline::getPathUpdated() {
  return  ::tmi::bundleshop::Time::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Source::Builder::setPathUpdated( ::tmi::bundleshop::Time::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::Time::Builder Source::Builder::initPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Source::Builder::adoptPathUpdated(
    ::capnp::Orphan< ::tmi::bundleshop::Time>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::Time> Source::Builder::disownPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Source::Reader::getUpdateAvailable() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}

inline bool Source::Builder::getUpdateAvailable() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS);
}
inline void Source::Builder::setUpdateAvailable(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<33>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::hasUuid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasUuid() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::UUID::Reader Bundle::Reader::getUuid() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::UUID::Builder Bundle::Builder::getUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::UUID::Pipeline Bundle::Pipeline::getUuid() {
  return  ::tmi::bundleshop::UUID::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Bundle::Builder::setUuid( ::tmi::bundleshop::UUID::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::UUID::Builder Bundle::Builder::initUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::adoptUuid(
    ::capnp::Orphan< ::tmi::bundleshop::UUID>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::UUID> Bundle::Builder::disownUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasOrigin() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasOrigin() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getOrigin() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getOrigin() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setOrigin( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initOrigin(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptOrigin(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownOrigin() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasCategory() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasCategory() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getCategory() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getCategory() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setCategory( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initCategory(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptCategory(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownCategory() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasHtmlURL() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasHtmlURL() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getHtmlURL() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getHtmlURL() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setHtmlURL( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initHtmlURL(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptHtmlURL(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownHtmlURL() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasDescription() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasDescription() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getDescription() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setDescription( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initDescription(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptDescription(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownDescription() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasContactName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasContactName() {
  return !_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getContactName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getContactName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setContactName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initContactName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptContactName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownContactName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<6>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasContactEmail() const {
  return !_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasContactEmail() {
  return !_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getContactEmail() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getContactEmail() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setContactEmail( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initContactEmail(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptContactEmail(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownContactEmail() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<7>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasUrl() const {
  return !_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasUrl() {
  return !_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getUrl() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setUrl( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initUrl(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptUrl(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownUrl() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<8>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasUrlUpdated() const {
  return !_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasUrlUpdated() {
  return !_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::Time::Reader Bundle::Reader::getUrlUpdated() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_reader.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::Time::Builder Bundle::Builder::getUrlUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::Time::Pipeline Bundle::Pipeline::getUrlUpdated() {
  return  ::tmi::bundleshop::Time::Pipeline(_typeless.getPointerField(9));
}
#endif  // !CAPNP_LITE
inline void Bundle::Builder::setUrlUpdated( ::tmi::bundleshop::Time::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::set(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::Time::Builder Bundle::Builder::initUrlUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::init(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::adoptUrlUpdated(
    ::capnp::Orphan< ::tmi::bundleshop::Time>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::adopt(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::Time> Bundle::Builder::disownUrlUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::disown(_builder.getPointerField(
      ::capnp::bounded<9>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasPath() const {
  return !_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasPath() {
  return !_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Bundle::Reader::getPath() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Bundle::Builder::getPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setPath( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Bundle::Builder::initPath(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptPath(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Bundle::Builder::disownPath() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<10>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasPathUpdated() const {
  return !_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasPathUpdated() {
  return !_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::Time::Reader Bundle::Reader::getPathUpdated() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_reader.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::Time::Builder Bundle::Builder::getPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::get(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::Time::Pipeline Bundle::Pipeline::getPathUpdated() {
  return  ::tmi::bundleshop::Time::Pipeline(_typeless.getPointerField(11));
}
#endif  // !CAPNP_LITE
inline void Bundle::Builder::setPathUpdated( ::tmi::bundleshop::Time::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::set(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::Time::Builder Bundle::Builder::initPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::init(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::adoptPathUpdated(
    ::capnp::Orphan< ::tmi::bundleshop::Time>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::adopt(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::Time> Bundle::Builder::disownPathUpdated() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Time>::disown(_builder.getPointerField(
      ::capnp::bounded<11>() * ::capnp::POINTERS));
}

inline  ::int32_t Bundle::Reader::getRank() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Bundle::Builder::getRank() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setRank( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Bundle::Reader::getSize() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Bundle::Builder::getSize() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setSize( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::getRequisite() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool Bundle::Builder::getRequisite() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setRequisite(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::getDefault() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}

inline bool Bundle::Builder::getDefault() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setDefault(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<65>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::getDependency() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}

inline bool Bundle::Builder::getDependency() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setDependency(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<66>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::getInstalled() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}

inline bool Bundle::Builder::getInstalled() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setInstalled(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<67>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::getUpdateAvailable() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS);
}

inline bool Bundle::Builder::getUpdateAvailable() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS);
}
inline void Bundle::Builder::setUpdateAvailable(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<68>() * ::capnp::ELEMENTS, value);
}

inline bool Bundle::Reader::hasKeychain() const {
  return !_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasKeychain() {
  return !_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader Bundle::Reader::getKeychain() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::get(_reader.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder Bundle::Builder::getKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::get(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline Bundle::Pipeline::getKeychain() {
  return  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Pipeline(_typeless.getPointerField(12));
}
#endif  // !CAPNP_LITE
inline void Bundle::Builder::setKeychain( ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::set(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>::Builder Bundle::Builder::initKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::init(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::adoptKeychain(
    ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::adopt(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>> Bundle::Builder::disownKeychain() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::MapT< ::capnp::Text,  ::capnp::Text>>::disown(_builder.getPointerField(
      ::capnp::bounded<12>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasGrammars() const {
  return !_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasGrammars() {
  return !_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Reader Bundle::Reader::getGrammars() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Builder Bundle::Builder::getGrammars() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setGrammars( ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>::Builder Bundle::Builder::initGrammars(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptGrammars(
    ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>> Bundle::Builder::disownGrammars() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Grammar,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<13>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasDependants() const {
  return !_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasDependants() {
  return !_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Reader Bundle::Reader::getDependants() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Builder Bundle::Builder::getDependants() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::setDependants( ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>::Builder Bundle::Builder::initDependants(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), size);
}
inline void Bundle::Builder::adoptDependants(
    ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>> Bundle::Builder::disownDependants() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::tmi::bundleshop::Bundle,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<14>() * ::capnp::POINTERS));
}

inline bool Bundle::Reader::hasSource() const {
  return !_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline bool Bundle::Builder::hasSource() {
  return !_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::Source::Reader Bundle::Reader::getSource() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::get(_reader.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::Source::Builder Bundle::Builder::getSource() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::get(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::Source::Pipeline Bundle::Pipeline::getSource() {
  return  ::tmi::bundleshop::Source::Pipeline(_typeless.getPointerField(15));
}
#endif  // !CAPNP_LITE
inline void Bundle::Builder::setSource( ::tmi::bundleshop::Source::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::set(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::Source::Builder Bundle::Builder::initSource() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::init(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}
inline void Bundle::Builder::adoptSource(
    ::capnp::Orphan< ::tmi::bundleshop::Source>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::adopt(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::Source> Bundle::Builder::disownSource() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::Source>::disown(_builder.getPointerField(
      ::capnp::bounded<15>() * ::capnp::POINTERS));
}

inline bool Grammar::Reader::hasUuid() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Grammar::Builder::hasUuid() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::tmi::bundleshop::UUID::Reader Grammar::Reader::getUuid() const {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::tmi::bundleshop::UUID::Builder Grammar::Builder::getUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::tmi::bundleshop::UUID::Pipeline Grammar::Pipeline::getUuid() {
  return  ::tmi::bundleshop::UUID::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Grammar::Builder::setUuid( ::tmi::bundleshop::UUID::Reader value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::tmi::bundleshop::UUID::Builder Grammar::Builder::initUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Grammar::Builder::adoptUuid(
    ::capnp::Orphan< ::tmi::bundleshop::UUID>&& value) {
  ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::tmi::bundleshop::UUID> Grammar::Builder::disownUuid() {
  return ::capnp::_::PointerHelpers< ::tmi::bundleshop::UUID>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Grammar::Reader::hasScope() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Grammar::Builder::hasScope() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Grammar::Reader::getScope() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Grammar::Builder::getScope() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Grammar::Builder::setScope( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Grammar::Builder::initScope(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), size);
}
inline void Grammar::Builder::adoptScope(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Grammar::Builder::disownScope() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Grammar::Reader::hasName() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Grammar::Builder::hasName() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Grammar::Reader::getName() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Grammar::Builder::getName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Grammar::Builder::setName( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Grammar::Builder::initName(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), size);
}
inline void Grammar::Builder::adoptName(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Grammar::Builder::disownName() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Grammar::Reader::hasFileTypes() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Grammar::Builder::hasFileTypes() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader Grammar::Reader::getFileTypes() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Grammar::Builder::getFileTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Grammar::Builder::setFileTypes( ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline void Grammar::Builder::setFileTypes(::kj::ArrayPtr<const  ::capnp::Text::Reader> value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>::Builder Grammar::Builder::initFileTypes(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), size);
}
inline void Grammar::Builder::adoptFileTypes(
    ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>> Grammar::Builder::disownFileTypes() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::capnp::Text,  ::capnp::Kind::BLOB>>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Grammar::Reader::hasModeLine() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Grammar::Builder::hasModeLine() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader Grammar::Reader::getModeLine() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder Grammar::Builder::getModeLine() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Grammar::Builder::setModeLine( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder Grammar::Builder::initModeLine(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), size);
}
inline void Grammar::Builder::adoptModeLine(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> Grammar::Builder::disownModeLine() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

